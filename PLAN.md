# План реализации инструмента для дизассемблирования NuGet пакетов

## Цель проекта

Создать инструмент, который извлекает публичные интерфейсы из .NET библиотек (NuGet пакетов) для помощи AI-агентам в работе с актуальными версиями библиотек.

## Требования

1. Анализ всех NuGet пакетов в решении (.sln)
2. Извлечение только публичных и protected членов (классы, методы, свойства, поля)
3. Извлечение XML-комментариев
4. Создание структуры папок: `NugetDisassembly/{PackageName}/{Version}/`
5. Организация C# файлов по namespace (создание поддиректорий)
6. Обработка дублирующихся имен классов через счетчик (первое появление: `TypeName.cs`, второе: `TypeName1.cs`, третье: `TypeName2.cs` и т.д.)
7. Только интерфейсы, без реализации (пустые тела методов или комментарии)

---

## Архитектура решения

**Выбранный подход: System.Reflection + Roslyn**

**Архитектура:**
1. **System.Reflection** для чтения метаданных (встроен в .NET)
2. **Roslyn** для генерации чистого C# кода
3. **Ручной парсинг XML-комментариев** из .xml файлов NuGet пакетов

**Преимущества:**
- System.Reflection встроен в .NET, не требует дополнительных зависимостей
- Roslyn позволяет генерировать синтаксически корректный C# код
- Хорошая поддержка XML-комментариев через `XmlDocumentationProvider`
- Гибкость и контроль над процессом
- Чистая генерация кода через Roslyn

**Структура (текущая реализация):**
```
Disassembly.Tool/
  ├── Core/
  │   ├── SolutionAnalyzer.cs          ✅ Парсинг .sln/.csproj через XDocument
  │   ├── NuGetPackageResolver.cs      ✅ Поиск в NuGet кэше (~/.nuget/packages)
  │   ├── AssemblyReflector.cs         ✅ Рефлексия сборок через System.Reflection + AssemblyLoadContext
  │   └── XmlDocumentationReader.cs   ❌ НЕ РЕАЛИЗОВАНО
  ├── Filters/
  │   └── MemberVisibilityFilter.cs   ✅ Фильтр публичных/protected
  ├── CodeGeneration/
  │   ├── RoslynCodeGenerator.cs      ✅ Генерация через Roslyn SyntaxFactory
  │   └── FileNameResolver.cs         ✅ Разрешение имен файлов с учетом счетчика
  ├── FileSystem/
  │   └── DirectoryStructureBuilder.cs ✅ Создание структуры папок
  └── Program.cs                       ✅ Точка входа CLI
```

**Стратегия обработки NuGet пакетов:**

Из-за того, что в одном проекте могут использоваться несколько версий одной и той же библиотеки, загрузка нескольких одинаково названных зависимостей в рантайме может вызвать конфликты. Для решения этой проблемы каждый NuGet пакет должен обрабатываться изолированно.

**Подход:**
- Использование `AssemblyLoadContext` для изоляции загрузки сборок каждого пакета
- Каждый пакет обрабатывается в отдельном контексте загрузки
- Обработка пакетов не должна мешать друг другу
- Изоляция обеспечивает отсутствие конфликтов при загрузке сборок с одинаковыми именами, но разными версиями

---

## Детальный план реализации

### Этап 1: Анализ решения и извлечение NuGet пакетов ✅ **РЕАЛИЗОВАНО**

**Задачи:**
1. ✅ Парсинг .sln файла для получения списка проектов
2. ✅ Парсинг каждого .csproj для извлечения `<PackageReference>`
3. ✅ Поиск DLL файлов в NuGet кэше (`~/.nuget/packages` или `%USERPROFILE%\.nuget\packages`)
4. ✅ Обработка версий пакетов (может быть несколько версий одного пакета)
5. ✅ Поиск XML файлов документации (путь сохраняется, но пока не используется)

**Технологии:**
- ✅ Ручной XML парсинг через `XDocument` для .csproj
- ✅ `System.IO` для работы с файловой системой

**Выходные данные:**
- ✅ Список `PackageInfo`: `(PackageName, Version, DllPath, XmlDocPath)`

**Реализованные компоненты:**
- ✅ `SolutionAnalyzer` - парсинг .sln и .csproj файлов
- ✅ `NuGetPackageResolver` - поиск пакетов в NuGet кэше, резолвинг DLL и XML путей

---

### Этап 2: Чтение метаданных сборок ✅ **РЕАЛИЗОВАНО**

**Задачи:**
1. ✅ Загрузка сборки через `AssemblyLoadContext.LoadFromAssemblyPath()` (изоляция через `AssemblyLoadContext`)
2. ✅ Извлечение всех типов (классы, интерфейсы, структуры, enum, делегаты)
3. ✅ Фильтрация по видимости (public, protected) через `MemberVisibilityFilter`
4. ✅ Извлечение членов типов (методы, свойства, поля, события, конструкторы)
5. ✅ Обработка generic типов и методов
6. ✅ Извлечение атрибутов - **РЕАЛИЗОВАНО** (атрибуты извлекаются из типов и членов, используются полные имена с namespace)

**Технологии:**
- ✅ `System.Reflection` для анализа метаданных (встроен в .NET)
- ✅ `AssemblyLoadContext` для изоляции загрузки сборок
- ✅ `Type.GetMembers()` для извлечения членов типов

**Ключевые моменты:**
- ✅ Игнорировать private/internal члены
- ✅ Сохранять информацию о generic параметрах
- ✅ Сохранять информацию о параметрах методов
- ✅ Сохранять информацию о возвращаемых типах
- ✅ Обработка вложенных типов (nested types)
- ✅ Игнорирование компилятор-генерированных типов
- ✅ Извлечение атрибутов из типов и членов (с полными именами и аргументами)
- ⚠️ Обработка зависимостей сборок - частично (загрузка через AssemblyLoadContext)

**Реализованные компоненты:**
- ✅ `AssemblyReflector` - извлечение метаданных через System.Reflection с изоляцией через AssemblyLoadContext
- ✅ `MemberVisibilityFilter` - фильтрация public/protected членов

---

### Этап 3: Извлечение XML-комментариев ⚠️ **ЧАСТИЧНО РЕАЛИЗОВАНО**

**Задачи:**
1. ✅ Поиск соответствующих .xml файлов документации в NuGet пакете (путь сохраняется в `PackageInfo.XmlDocPath`)
2. ❌ Парсинг XML документации - **НЕ РЕАЛИЗОВАНО**
3. ❌ Сопоставление комментариев с типами и членами через XML ID - **НЕ РЕАЛИЗОВАНО**
4. ❌ Извлечение `<summary>`, `<param>`, `<returns>`, `<remarks>`, `<exception>` - **НЕ РЕАЛИЗОВАНО**

**Формат XML ID в .NET:**
- Тип: `T:Namespace.TypeName`
- Метод: `M:Namespace.TypeName.MethodName(ParamType1,ParamType2)`
- Свойство: `P:Namespace.TypeName.PropertyName`
- Поле: `F:Namespace.TypeName.FieldName`

**Статус:**
- Путь к XML файлу находится и сохраняется, но компонент `XmlDocumentationReader` не реализован
- XML комментарии не добавляются в генерируемый код

---

### Этап 4: Генерация C# кода ✅ **РЕАЛИЗОВАНО** (частично)

**Задачи:**
1. ✅ Создание синтаксических деревьев через Roslyn `SyntaxFactory`
2. ✅ Генерация объявлений типов с правильными модификаторами (public, protected, abstract, sealed, static)
3. ✅ Генерация методов с сигнатурами (без реализации, с комментарием `// Implementation in original library`)
4. ✅ Генерация свойств, полей, событий, конструкторов
5. ✅ Генерация индексаторов
6. ✅ Обработка generic типов и методов
7. ✅ Обработка enum с явными значениями
8. ✅ Обработка вложенных типов
9. ✅ Обработка базовых типов и интерфейсов
10. ✅ Форматирование кода через Roslyn `Formatter`
11. ✅ Генерация атрибутов для типов и членов - **РЕАЛИЗОВАНО** (атрибуты генерируются с полными именами, поддерживаются позиционные и именованные аргументы)
12. ❌ Добавление XML-комментариев - **НЕ РЕАЛИЗОВАНО** (ожидает реализацию Этапа 3)

**Пример генерации метода (текущая реализация):**
```csharp
public ReturnType MethodName(ParamType param1)
{
    // Implementation in original library
}
```

**Реализованные компоненты:**
- ✅ `RoslynCodeGenerator` - генерация C# кода через Roslyn
- ✅ Поддержка всех типов: классы, интерфейсы, структуры, enum, делегаты
- ✅ Поддержка всех модификаторов: public, protected, static, abstract, virtual, sealed
- ✅ Генерация атрибутов с полными именами (namespace) и аргументами

---

### Этап 5: Организация файлов по структуре ✅ **РЕАЛИЗОВАНО**

**Задачи:**
1. ✅ Создание структуры папок: `NugetDisassembly/{PackageName}/{Version}/`
2. ✅ Разделение по namespace (создание поддиректорий)
3. ✅ Именование файлов:
   - Первое появление класса: `TypeName.cs`
   - Второе появление (дубликат): `TypeName1.cs`
   - Третье появление: `TypeName2.cs`
   - И так далее (счетчик начинается с 1 для второго файла)
4. ❌ Копирование не-C# файлов - **НЕ РЕАЛИЗОВАНО**

**Пример структуры (реализовано):**
```
NugetDisassembly/
  └── Newtonsoft.Json/
      └── 13.0.4/
          └── Newtonsoft/
              └── Json/
                  ├── JsonConverter.cs
                  ├── JsonConverter1.cs
                  └── Converters/
                      └── StringEnumConverter.cs
```

**Реализованные компоненты:**
- ✅ `DirectoryStructureBuilder` - создание структуры директорий по namespace
- ✅ `FileNameResolver` - разрешение имен файлов с обработкой дубликатов через счетчик

---

### Этап 6: Обработка edge cases ⚠️ **ЧАСТИЧНО РЕАЛИЗОВАНО**

**Задачи:**
1. ✅ Обработка вложенных типов (nested types) - реализовано, вложенные типы генерируются внутри родительского типа
2. ✅ Обработка атрибутов - **РЕАЛИЗОВАНО** (атрибуты извлекаются из типов и членов, генерируются в коде с полными именами и аргументами)
3. ✅ Обработка перегрузок методов - реализовано (все перегрузки генерируются)
4. ⚠️ Обработка явных реализаций интерфейсов - **НЕ ПРОВЕРЕНО** (может требовать специальной обработки)
5. ✅ Обработка статических членов - реализовано (модификатор `static` генерируется)
6. ✅ Обработка extension методов - **РЕАЛИЗОВАНО** (extension методы определяются через ExtensionAttribute и генерируются с ключевым словом `this` для первого параметра)
7. ✅ Обработка nullable reference types - **РЕАЛИЗОВАНО** (nullable reference types определяются из метаданных через NullableAttribute и помечаются явно через `?`)

---

## Интерфейс инструмента ✅ **РЕАЛИЗОВАНО** (базовый функционал)

**CLI инструмент**

```bash
dotnet-disassembly [options]

Options:
  --solution, -s <path>  Путь к .sln файлу (обязательный)
  --output, -o <path>   Путь для вывода (по умолчанию: ./NugetDisassembly)
  --help, -h            Показать справку
```

**Реализованные опции:**
- ✅ `--solution, -s` - обязательный параметр, путь к .sln файлу
- ✅ `--output, -o` - опциональный параметр, путь для вывода (по умолчанию: `./NugetDisassembly`)
- ✅ `--help, -h` - справка

**Не реализованные опции:**
- ❌ `--packages <list>` - фильтрация по конкретным пакетам
- ❌ `--include-private` - включение private членов
- ❌ `--include-implementation` - включение реализаций методов

## Порядок реализации

1. ✅ Реализовать CLI инструмент - **ЗАВЕРШЕНО**
2. ✅ Реализовать базовый функционал для одного пакета - **ЗАВЕРШЕНО**
3. ✅ Добавить обработку всего решения - **ЗАВЕРШЕНО**
4. ⚠️ Добавить обработку edge cases - **В ПРОЦЕССЕ** (частично реализовано)
5. ⚠️ Оптимизировать и добавить опции - **В ПРОЦЕССЕ** (базовые опции реализованы)

## Текущий статус реализации

### ✅ Реализовано:
- CLI инструмент с базовыми опциями
- Парсинг .sln и .csproj файлов
- Поиск и резолвинг NuGet пакетов в кэше
- Извлечение метаданных через System.Reflection с изоляцией через AssemblyLoadContext
- Фильтрация public/protected членов
- Генерация C# кода через Roslyn для всех основных типов (классы, интерфейсы, структуры, enum, делегаты)
- Организация файлов по namespace
- Обработка дубликатов имен через счетчик
- Обработка generic типов и методов
- Обработка вложенных типов
- Обработка enum с явными значениями
- Обработка extension методов (определение через ExtensionAttribute, генерация с ключевым словом `this`)
- Обработка атрибутов (извлечение из типов и членов, генерация с полными именами и аргументами)
- Базовое тестирование всех компонентов (проект `Disassembly.Tool.Tests` с тестами для всех основных компонентов, включая тесты для атрибутов)

### ⚠️ Частично реализовано:
- XML документация (путь находится, но парсинг и интеграция не реализованы)
- Edge cases (некоторые обработаны, некоторые требуют доработки)

### ❌ Не реализовано:
- Парсинг и интеграция XML комментариев в генерируемый код
- Дополнительные CLI опции (--packages, --include-private, --include-implementation)
- Копирование не-C# файлов из пакетов

---

## Зависимости (текущие)

```xml
<PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="4.8.0" />
<PackageReference Include="Microsoft.CodeAnalysis.CSharp.Workspaces" Version="4.8.0" />
<PackageReference Include="Microsoft.Build" Version="17.8.0" />
```

**Примечание:** 
- System.Reflection встроен в .NET, дополнительных зависимостей не требуется
- System.Xml.Linq используется для парсинга .csproj (встроен в .NET)
- Microsoft.Build используется, но парсинг .csproj реализован через XDocument

---

## Вопросы для уточнения

1. ~~Нужно ли включать атрибуты в генерируемый код?~~ Решено: да, атрибуты включаются в генерируемый код
2. ~~Как обрабатывать вложенные типы (nested types)?~~ Решено: переиспользование счетчика для именования файлов
3. Нужна ли поддержка старых форматов проектов (.csproj с packages.config)?
4. Нужна ли поддержка .NET Framework библиотек?
5. ~~Как обрабатывать конфликты имен файлов (кроме generic)?~~ Решено: использование счетчика (TypeName.cs, TypeName1.cs, TypeName2.cs, ...)
6. Нужна ли поддержка F# или VB.NET библиотек?

